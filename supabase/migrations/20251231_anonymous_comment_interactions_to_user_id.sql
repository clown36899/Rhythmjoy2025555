-- Migrate anonymous comment interactions from fingerprint to user_id based
-- This ensures 1 person 1 vote integrity by requiring login for likes/dislikes

-- 1. Drop existing anonymous comment interaction tables
DROP TABLE IF EXISTS public.board_anonymous_comment_likes CASCADE;
DROP TABLE IF EXISTS public.board_anonymous_comment_dislikes CASCADE;

-- 2. Recreate tables with user_id instead of fingerprint
CREATE TABLE public.board_anonymous_comment_likes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    comment_id bigint REFERENCES public.board_anonymous_comments(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id, comment_id)
);

CREATE TABLE public.board_anonymous_comment_dislikes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    comment_id bigint REFERENCES public.board_anonymous_comments(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id, comment_id)
);

-- 3. Enable RLS
ALTER TABLE public.board_anonymous_comment_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.board_anonymous_comment_dislikes ENABLE ROW LEVEL SECURITY;

-- 4. Policies - Same as standard comments (user-based)
DROP POLICY IF EXISTS "Anon comment likes viewable by everyone" ON public.board_anonymous_comment_likes;
CREATE POLICY "Anon comment likes viewable by everyone" ON public.board_anonymous_comment_likes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Anon comment dislikes viewable by everyone" ON public.board_anonymous_comment_dislikes;
CREATE POLICY "Anon comment dislikes viewable by everyone" ON public.board_anonymous_comment_dislikes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can manage own anon comment likes" ON public.board_anonymous_comment_likes;
CREATE POLICY "Users can manage own anon comment likes" ON public.board_anonymous_comment_likes FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can manage own anon comment dislikes" ON public.board_anonymous_comment_dislikes;
CREATE POLICY "Users can manage own anon comment dislikes" ON public.board_anonymous_comment_dislikes FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- 5. Recreate triggers for count syncing
DROP TRIGGER IF EXISTS tr_sync_anon_comment_likes ON public.board_anonymous_comment_likes;
CREATE TRIGGER tr_sync_anon_comment_likes AFTER INSERT OR DELETE ON public.board_anonymous_comment_likes FOR EACH ROW EXECUTE FUNCTION public.sync_comment_counts();

DROP TRIGGER IF EXISTS tr_sync_anon_comment_dislikes ON public.board_anonymous_comment_dislikes;
CREATE TRIGGER tr_sync_anon_comment_dislikes AFTER INSERT OR DELETE ON public.board_anonymous_comment_dislikes FOR EACH ROW EXECUTE FUNCTION public.sync_comment_counts();

-- 6. Update RPC function to use user_id for anonymous comments
CREATE OR REPLACE FUNCTION public.toggle_comment_interaction(
    p_comment_id text,
    p_type text,
    p_is_anonymous boolean,
    p_fingerprint text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id uuid;
    v_likes_table text;
    v_dislikes_table text;
    v_current_table text;
    v_opposite_table text;
    v_exists boolean;
    v_comment_id_uuid uuid;
    v_comment_id_bigint bigint;
BEGIN
    v_user_id := auth.uid();
    
    -- Both anonymous and standard now require authentication
    IF v_user_id IS NULL THEN 
        RAISE EXCEPTION 'Authentication required for comment interactions'; 
    END IF;
    
    IF p_is_anonymous THEN
        v_likes_table := 'board_anonymous_comment_likes';
        v_dislikes_table := 'board_anonymous_comment_dislikes';
        v_comment_id_bigint := p_comment_id::bigint;
    ELSE
        v_likes_table := 'board_comment_likes';
        v_dislikes_table := 'board_comment_dislikes';
        v_comment_id_uuid := p_comment_id::uuid;
    END IF;

    IF p_type = 'like' THEN
        v_current_table := v_likes_table;
        v_opposite_table := v_dislikes_table;
    ELSE
        v_current_table := v_dislikes_table;
        v_opposite_table := v_likes_table;
    END IF;

    -- Check existence using user_id for both anonymous and standard
    IF p_is_anonymous THEN
        EXECUTE format('SELECT EXISTS (SELECT 1 FROM public.%I WHERE comment_id = $1 AND user_id = $2)', v_current_table)
        INTO v_exists USING v_comment_id_bigint, v_user_id;
    ELSE
        EXECUTE format('SELECT EXISTS (SELECT 1 FROM public.%I WHERE comment_id = $1 AND user_id = $2)', v_current_table)
        INTO v_exists USING v_comment_id_uuid, v_user_id;
    END IF;

    IF v_exists THEN
        -- Toggle OFF
        IF p_is_anonymous THEN
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND user_id = $2', v_current_table)
            USING v_comment_id_bigint, v_user_id;
        ELSE
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND user_id = $2', v_current_table)
            USING v_comment_id_uuid, v_user_id;
        END IF;
        RETURN jsonb_build_object('status', 'removed', 'type', p_type);
    ELSE
        -- Toggle ON: Remove opposite and add current
        IF p_is_anonymous THEN
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND user_id = $2', v_opposite_table)
            USING v_comment_id_bigint, v_user_id;
            EXECUTE format('INSERT INTO public.%I (comment_id, user_id) VALUES ($1, $2)', v_current_table)
            USING v_comment_id_bigint, v_user_id;
        ELSE
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND user_id = $2', v_opposite_table)
            USING v_comment_id_uuid, v_user_id;
            EXECUTE format('INSERT INTO public.%I (comment_id, user_id) VALUES ($1, $2)', v_current_table)
            USING v_comment_id_uuid, v_user_id;
        END IF;
        RETURN jsonb_build_object('status', 'added', 'type', p_type);
    END IF;
END;
$$;

NOTIFY pgrst, 'reload schema';
