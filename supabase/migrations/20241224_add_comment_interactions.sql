-- 1. Add likes/dislikes columns to comment tables
ALTER TABLE public.board_comments 
ADD COLUMN IF NOT EXISTS likes integer DEFAULT 0,
ADD COLUMN IF NOT EXISTS dislikes integer DEFAULT 0;

ALTER TABLE public.board_anonymous_comments 
ADD COLUMN IF NOT EXISTS likes integer DEFAULT 0,
ADD COLUMN IF NOT EXISTS dislikes integer DEFAULT 0;

-- 2. Create interaction tables for board_comments (Authenticated)
CREATE TABLE IF NOT EXISTS public.board_comment_likes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    comment_id uuid REFERENCES public.board_comments(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id, comment_id)
);

CREATE TABLE IF NOT EXISTS public.board_comment_dislikes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    comment_id uuid REFERENCES public.board_comments(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id, comment_id)
);

-- 3. Create interaction tables for board_anonymous_comments (Fingerprint)
CREATE TABLE IF NOT EXISTS public.board_anonymous_comment_likes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fingerprint text NOT NULL,
    comment_id bigint REFERENCES public.board_anonymous_comments(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(fingerprint, comment_id)
);

CREATE TABLE IF NOT EXISTS public.board_anonymous_comment_dislikes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fingerprint text NOT NULL,
    comment_id bigint REFERENCES public.board_anonymous_comments(id) ON DELETE CASCADE NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(fingerprint, comment_id)
);

-- 4. Enable RLS
ALTER TABLE public.board_comment_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.board_comment_dislikes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.board_anonymous_comment_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.board_anonymous_comment_dislikes ENABLE ROW LEVEL SECURITY;

-- 5. Policies
-- Select: Open to everyone
DROP POLICY IF EXISTS "Comment likes viewable by everyone" ON public.board_comment_likes;
CREATE POLICY "Comment likes viewable by everyone" ON public.board_comment_likes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Comment dislikes viewable by everyone" ON public.board_comment_dislikes;
CREATE POLICY "Comment dislikes viewable by everyone" ON public.board_comment_dislikes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Anon comment likes viewable by everyone" ON public.board_anonymous_comment_likes;
CREATE POLICY "Anon comment likes viewable by everyone" ON public.board_anonymous_comment_likes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Anon comment dislikes viewable by everyone" ON public.board_anonymous_comment_dislikes;
CREATE POLICY "Anon comment dislikes viewable by everyone" ON public.board_anonymous_comment_dislikes FOR SELECT USING (true);

-- Insert/Delete: Owner based for auth users
DROP POLICY IF EXISTS "Users can manage own comment likes" ON public.board_comment_likes;
CREATE POLICY "Users can manage own comment likes" ON public.board_comment_likes FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can manage own comment dislikes" ON public.board_comment_dislikes;
CREATE POLICY "Users can manage own comment dislikes" ON public.board_comment_dislikes FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Insert/Delete: Open for anonymous (handled by fingerprint in app logic)
DROP POLICY IF EXISTS "Anyone can interact with anon comments" ON public.board_anonymous_comment_likes;
CREATE POLICY "Anyone can interact with anon comments" ON public.board_anonymous_comment_likes FOR ALL USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "Anyone can interact with anon comments dislikes" ON public.board_anonymous_comment_dislikes;
CREATE POLICY "Anyone can interact with anon comments dislikes" ON public.board_anonymous_comment_dislikes FOR ALL USING (true) WITH CHECK (true);

-- 6. Trigger functions for syncing counts
CREATE OR REPLACE FUNCTION public.sync_comment_counts()
RETURNS TRIGGER AS $$
DECLARE
    v_table_name text;
    v_target_table text;
    v_comment_id_text text;
    v_likes integer;
    v_dislikes integer;
BEGIN
    v_table_name := TG_TABLE_NAME;
    v_comment_id_text := COALESCE(NEW.comment_id, OLD.comment_id)::text;

    IF v_table_name LIKE 'board_anonymous%' THEN
        v_target_table := 'board_anonymous_comments';
        -- For anonymous comments (ID is bigint)
        SELECT count(*) INTO v_likes FROM public.board_anonymous_comment_likes WHERE comment_id = v_comment_id_text::bigint;
        SELECT count(*) INTO v_dislikes FROM public.board_anonymous_comment_dislikes WHERE comment_id = v_comment_id_text::bigint;
        
        UPDATE public.board_anonymous_comments 
        SET likes = v_likes, dislikes = v_dislikes 
        WHERE id = v_comment_id_text::bigint;
    ELSE
        v_target_table := 'board_comments';
        -- For standard comments (ID is uuid)
        SELECT count(*) INTO v_likes FROM public.board_comment_likes WHERE comment_id = v_comment_id_text::uuid;
        SELECT count(*) INTO v_dislikes FROM public.board_comment_dislikes WHERE comment_id = v_comment_id_text::uuid;

        UPDATE public.board_comments 
        SET likes = v_likes, dislikes = v_dislikes 
        WHERE id = v_comment_id_text::uuid;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. Attach triggers
DROP TRIGGER IF EXISTS tr_sync_comment_likes ON public.board_comment_likes;
CREATE TRIGGER tr_sync_comment_likes AFTER INSERT OR DELETE ON public.board_comment_likes FOR EACH ROW EXECUTE FUNCTION public.sync_comment_counts();

DROP TRIGGER IF EXISTS tr_sync_comment_dislikes ON public.board_comment_dislikes;
CREATE TRIGGER tr_sync_comment_dislikes AFTER INSERT OR DELETE ON public.board_comment_dislikes FOR EACH ROW EXECUTE FUNCTION public.sync_comment_counts();

DROP TRIGGER IF EXISTS tr_sync_anon_comment_likes ON public.board_anonymous_comment_likes;
CREATE TRIGGER tr_sync_anon_comment_likes AFTER INSERT OR DELETE ON public.board_anonymous_comment_likes FOR EACH ROW EXECUTE FUNCTION public.sync_comment_counts();

DROP TRIGGER IF EXISTS tr_sync_anon_comment_dislikes ON public.board_anonymous_comment_dislikes;
CREATE TRIGGER tr_sync_anon_comment_dislikes AFTER INSERT OR DELETE ON public.board_anonymous_comment_dislikes FOR EACH ROW EXECUTE FUNCTION public.sync_comment_counts();

-- 8. Atomic Toggle RPC
-- Drop old signature to avoid confusion with the new polymorphic (text) version
DROP FUNCTION IF EXISTS public.toggle_comment_interaction(bigint, text, boolean, text);

CREATE OR REPLACE FUNCTION public.toggle_comment_interaction(
    p_comment_id text, -- Accepts both bigint (anon) and uuid (standard) as text
    p_type text, -- 'like' or 'dislike'
    p_is_anonymous boolean,
    p_fingerprint text DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id uuid;
    v_likes_table text;
    v_dislikes_table text;
    v_current_table text;
    v_opposite_table text;
    v_exists boolean;
    v_comment_id_uuid uuid;
    v_comment_id_bigint bigint;
BEGIN
    v_user_id := auth.uid();
    
    IF p_is_anonymous THEN
        IF p_fingerprint IS NULL THEN RAISE EXCEPTION 'Fingerprint required for anonymous interaction'; END IF;
        v_likes_table := 'board_anonymous_comment_likes';
        v_dislikes_table := 'board_anonymous_comment_dislikes';
        v_comment_id_bigint := p_comment_id::bigint;
    ELSE
        IF v_user_id IS NULL THEN RAISE EXCEPTION 'Authentication required'; END IF;
        v_likes_table := 'board_comment_likes';
        v_dislikes_table := 'board_comment_dislikes';
        v_comment_id_uuid := p_comment_id::uuid;
    END IF;

    IF p_type = 'like' THEN
        v_current_table := v_likes_table;
        v_opposite_table := v_dislikes_table;
    ELSE
        v_current_table := v_dislikes_table;
        v_opposite_table := v_likes_table;
    END IF;

    -- Check existence using explicitly casted IDs
    IF p_is_anonymous THEN
        EXECUTE format('SELECT EXISTS (SELECT 1 FROM public.%I WHERE comment_id = $1 AND fingerprint = $2)', v_current_table)
        INTO v_exists USING v_comment_id_bigint, p_fingerprint;
    ELSE
        EXECUTE format('SELECT EXISTS (SELECT 1 FROM public.%I WHERE comment_id = $1 AND user_id = $2)', v_current_table)
        INTO v_exists USING v_comment_id_uuid, v_user_id;
    END IF;

    IF v_exists THEN
        -- Toggle OFF
        IF p_is_anonymous THEN
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND fingerprint = $2', v_current_table)
            USING v_comment_id_bigint, p_fingerprint;
        ELSE
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND user_id = $2', v_current_table)
            USING v_comment_id_uuid, v_user_id;
        END IF;
        RETURN jsonb_build_object('status', 'removed', 'type', p_type);
    ELSE
        -- Toggle ON: Remove opposite and add current
        IF p_is_anonymous THEN
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND fingerprint = $2', v_opposite_table)
            USING v_comment_id_bigint, p_fingerprint;
            EXECUTE format('INSERT INTO public.%I (comment_id, fingerprint) VALUES ($1, $2)', v_current_table)
            USING v_comment_id_bigint, p_fingerprint;
        ELSE
            EXECUTE format('DELETE FROM public.%I WHERE comment_id = $1 AND user_id = $2', v_opposite_table)
            USING v_comment_id_uuid, v_user_id;
            EXECUTE format('INSERT INTO public.%I (comment_id, user_id) VALUES ($1, $2)', v_current_table)
            USING v_comment_id_uuid, v_user_id;
        END IF;
        RETURN jsonb_build_object('status', 'added', 'type', p_type);
    END IF;
END;
$$;

NOTIFY pgrst, 'reload schema';

NOTIFY pgrst, 'reload schema';
