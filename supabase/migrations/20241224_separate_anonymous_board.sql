-- 1. Create separate tables for Anonymous Board
-- Post table
CREATE TABLE IF NOT EXISTS public.board_anonymous_posts (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title text NOT NULL,
    content text NOT NULL,
    author_name text NOT NULL,
    author_nickname text,
    image text,
    image_thumbnail text,
    password text NOT NULL,
    views integer DEFAULT 0,
    likes integer DEFAULT 0,
    dislikes integer DEFAULT 0,
    is_notice boolean DEFAULT false,
    is_hidden boolean DEFAULT false,
    comment_count integer DEFAULT 0,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Ensure columns exist even if the table was created previously without them
ALTER TABLE public.board_anonymous_posts ADD COLUMN IF NOT EXISTS comment_count integer DEFAULT 0;
ALTER TABLE public.board_anonymous_posts ADD COLUMN IF NOT EXISTS display_order integer DEFAULT 0;
ALTER TABLE public.board_anonymous_posts ADD COLUMN IF NOT EXISTS is_hidden boolean DEFAULT false;

-- Comments table
CREATE TABLE IF NOT EXISTS public.board_anonymous_comments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    post_id bigint REFERENCES public.board_anonymous_posts(id) ON DELETE CASCADE NOT NULL,
    content text NOT NULL,
    author_name text NOT NULL,
    password text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Likes table
CREATE TABLE IF NOT EXISTS public.board_anonymous_likes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    post_id bigint REFERENCES public.board_anonymous_posts(id) ON DELETE CASCADE NOT NULL,
    fingerprint text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(post_id, fingerprint)
);

-- Dislikes table
CREATE TABLE IF NOT EXISTS public.board_anonymous_dislikes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    post_id bigint REFERENCES public.board_anonymous_posts(id) ON DELETE CASCADE NOT NULL,
    fingerprint text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(post_id, fingerprint)
);

-- 2. Enable RLS
ALTER TABLE public.board_anonymous_posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.board_anonymous_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.board_anonymous_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.board_anonymous_dislikes ENABLE ROW LEVEL SECURITY;

-- 3. Policies (Idempotent)
DO $$ 
BEGIN
    -- Posts
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anonymous posts are viewable by everyone' AND tablename = 'board_anonymous_posts') THEN
        CREATE POLICY "Anonymous posts are viewable by everyone" ON public.board_anonymous_posts FOR SELECT USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anyone can insert anonymous posts' AND tablename = 'board_anonymous_posts') THEN
        CREATE POLICY "Anyone can insert anonymous posts" ON public.board_anonymous_posts FOR INSERT WITH CHECK (true);
    END IF;

    -- Comments
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anonymous comments are viewable by everyone' AND tablename = 'board_anonymous_comments') THEN
        CREATE POLICY "Anonymous comments are viewable by everyone" ON public.board_anonymous_comments FOR SELECT USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anyone can insert anonymous comments' AND tablename = 'board_anonymous_comments') THEN
        CREATE POLICY "Anyone can insert anonymous comments" ON public.board_anonymous_comments FOR INSERT WITH CHECK (true);
    END IF;

    -- Likes
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anonymous likes are viewable by everyone' AND tablename = 'board_anonymous_likes') THEN
        CREATE POLICY "Anonymous likes are viewable by everyone" ON public.board_anonymous_likes FOR SELECT USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anyone can insert anonymous likes' AND tablename = 'board_anonymous_likes') THEN
        CREATE POLICY "Anyone can insert anonymous likes" ON public.board_anonymous_likes FOR INSERT WITH CHECK (true);
    END IF;

    -- Dislikes
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anonymous dislikes are viewable by everyone' AND tablename = 'board_anonymous_dislikes') THEN
        CREATE POLICY "Anonymous dislikes are viewable by everyone" ON public.board_anonymous_dislikes FOR SELECT USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Anyone can insert anonymous dislikes' AND tablename = 'board_anonymous_dislikes') THEN
        CREATE POLICY "Anyone can insert anonymous dislikes" ON public.board_anonymous_dislikes FOR INSERT WITH CHECK (true);
    END IF;

    -- ADMIN POLICIES
    -- Posts
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Admins have full access to anonymous posts' AND tablename = 'board_anonymous_posts') THEN
        CREATE POLICY "Admins have full access to anonymous posts" ON public.board_anonymous_posts FOR ALL USING (public.is_admin_user()) WITH CHECK (public.is_admin_user());
    END IF;
    -- Comments
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Admins have full access to anonymous comments' AND tablename = 'board_anonymous_comments') THEN
        CREATE POLICY "Admins have full access to anonymous comments" ON public.board_anonymous_comments FOR ALL USING (public.is_admin_user()) WITH CHECK (public.is_admin_user());
    END IF;
    -- Likes
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Admins have full access to anonymous likes' AND tablename = 'board_anonymous_likes') THEN
        CREATE POLICY "Admins have full access to anonymous likes" ON public.board_anonymous_likes FOR ALL USING (public.is_admin_user()) WITH CHECK (public.is_admin_user());
    END IF;
    -- Dislikes
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Admins have full access to anonymous dislikes' AND tablename = 'board_anonymous_dislikes') THEN
        CREATE POLICY "Admins have full access to anonymous dislikes" ON public.board_anonymous_dislikes FOR ALL USING (public.is_admin_user()) WITH CHECK (public.is_admin_user());
    END IF;
END $$;

-- 4. Triggers for counts (Idempotent)
-- Sync likes count
CREATE OR REPLACE FUNCTION public.sync_anonymous_post_likes()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.board_anonymous_posts 
    SET likes = (SELECT count(*) FROM public.board_anonymous_likes WHERE post_id = COALESCE(NEW.post_id, OLD.post_id))
    WHERE id = COALESCE(NEW.post_id, OLD.post_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tr_sync_anonymous_post_likes ON public.board_anonymous_likes;
CREATE TRIGGER tr_sync_anonymous_post_likes
AFTER INSERT OR DELETE ON public.board_anonymous_likes
FOR EACH ROW EXECUTE FUNCTION public.sync_anonymous_post_likes();

-- Sync dislikes and auto-hide
CREATE OR REPLACE FUNCTION public.sync_anonymous_post_dislikes()
RETURNS TRIGGER AS $$
DECLARE
    d_count integer;
BEGIN
    SELECT count(*) INTO d_count FROM public.board_anonymous_dislikes WHERE post_id = COALESCE(NEW.post_id, OLD.post_id);
    
    UPDATE public.board_anonymous_posts 
    SET 
        dislikes = d_count,
        is_hidden = (d_count >= 2)
    WHERE id = COALESCE(NEW.post_id, OLD.post_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tr_sync_anonymous_post_dislikes ON public.board_anonymous_dislikes;
CREATE TRIGGER tr_sync_anonymous_post_dislikes
AFTER INSERT OR DELETE ON public.board_anonymous_dislikes
FOR EACH ROW EXECUTE FUNCTION public.sync_anonymous_post_dislikes();

-- Sync comment count
CREATE OR REPLACE FUNCTION public.sync_anonymous_comment_count()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.board_anonymous_posts 
    SET comment_count = (SELECT count(*) FROM public.board_anonymous_comments WHERE post_id = COALESCE(NEW.post_id, OLD.post_id))
    WHERE id = COALESCE(NEW.post_id, OLD.post_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tr_sync_anonymous_comment_count ON public.board_anonymous_comments;
CREATE TRIGGER tr_sync_anonymous_comment_count
AFTER INSERT OR DELETE ON public.board_anonymous_comments
FOR EACH ROW EXECUTE FUNCTION public.sync_anonymous_comment_count();

-- 5. Secure RPC Functions for Anonymous Board
CREATE OR REPLACE FUNCTION public.verify_anonymous_post_password(p_post_id bigint, p_password text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM public.board_anonymous_posts 
        WHERE id = p_post_id AND password = p_password
    );
END;
$$;

CREATE OR REPLACE FUNCTION public.delete_anonymous_post_with_password(p_post_id bigint, p_password text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Allow delete if user is admin OR if password matches
    IF public.is_admin_user() OR EXISTS (SELECT 1 FROM public.board_anonymous_posts WHERE id = p_post_id AND password = p_password) THEN
        -- Delete dependencies
        DELETE FROM public.board_anonymous_comments WHERE post_id = p_post_id;
        DELETE FROM public.board_anonymous_likes WHERE post_id = p_post_id;
        DELETE FROM public.board_anonymous_dislikes WHERE post_id = p_post_id;
        
        -- Delete the post
        DELETE FROM public.board_anonymous_posts WHERE id = p_post_id;
        RETURN true;
    ELSE
        RETURN false;
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_anonymous_post_with_password(
    p_post_id bigint, 
    p_password text,
    p_title text,
    p_content text,
    p_author_name text,
    p_image text,
    p_image_thumbnail text
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM public.board_anonymous_posts WHERE id = p_post_id AND password = p_password) THEN
        UPDATE public.board_anonymous_posts 
        SET 
            title = p_title,
            content = p_content,
            author_name = p_author_name,
            author_nickname = p_author_name,
            image = COALESCE(p_image, image),
            image_thumbnail = COALESCE(p_image_thumbnail, image_thumbnail),
            updated_at = now()
        WHERE id = p_post_id;
        RETURN true;
    ELSE
        RETURN false;
    END IF;
END;
$$;

-- 5-1. Atomic Toggle Interaction for Anonymous Board
-- Handles Like/Dislike with mutual exclusivity in a single call
CREATE OR REPLACE FUNCTION public.toggle_anonymous_interaction(
    p_post_id bigint,
    p_fingerprint text,
    p_type text -- 'like' or 'dislike'
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_table text;
    v_opposite_table text;
    v_exists boolean;
    v_result jsonb;
BEGIN
    IF p_type = 'like' THEN
        v_table := 'board_anonymous_likes';
        v_opposite_table := 'board_anonymous_dislikes';
    ELSIF p_type = 'dislike' THEN
        v_table := 'board_anonymous_dislikes';
        v_opposite_table := 'board_anonymous_likes';
    ELSE
        RAISE EXCEPTION 'Invalid interaction type. Use ''like'' or ''dislike''.';
    END IF;

    -- Check if current interaction exists
    EXECUTE format('SELECT EXISTS (SELECT 1 FROM public.%I WHERE post_id = $1 AND fingerprint = $2)', v_table)
    INTO v_exists
    USING p_post_id, p_fingerprint;

    IF v_exists THEN
        -- Toggle OFF: Remove current
        EXECUTE format('DELETE FROM public.%I WHERE post_id = $1 AND fingerprint = $2', v_table)
        USING p_post_id, p_fingerprint;
        v_result := jsonb_build_object('status', 'removed', 'type', p_type);
    ELSE
        -- Toggle ON: Insert current and remove opposite
        EXECUTE format('DELETE FROM public.%I WHERE post_id = $1 AND fingerprint = $2', v_opposite_table)
        USING p_post_id, p_fingerprint;
        
        EXECUTE format('INSERT INTO public.%I (post_id, fingerprint) VALUES ($1, $2)', v_table)
        USING p_post_id, p_fingerprint;
        v_result := jsonb_build_object('status', 'added', 'type', p_type);
    END IF;

    RETURN v_result;
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object('status', 'error', 'message', SQLERRM);
END;
$$;

-- 6. Strict Interaction Logic (Mutual Exclusivity)
-- Remove dislike when like is added
CREATE OR REPLACE FUNCTION public.handle_anonymous_mutual_like()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM public.board_anonymous_dislikes 
    WHERE post_id = NEW.post_id AND fingerprint = NEW.fingerprint;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tr_anonymous_mutual_like ON public.board_anonymous_likes;
CREATE TRIGGER tr_anonymous_mutual_like
BEFORE INSERT ON public.board_anonymous_likes
FOR EACH ROW EXECUTE FUNCTION public.handle_anonymous_mutual_like();

-- Remove like when dislike is added
CREATE OR REPLACE FUNCTION public.handle_anonymous_mutual_dislike()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM public.board_anonymous_likes 
    WHERE post_id = NEW.post_id AND fingerprint = NEW.fingerprint;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tr_anonymous_mutual_dislike ON public.board_anonymous_dislikes;
CREATE TRIGGER tr_anonymous_mutual_dislike
BEFORE INSERT ON public.board_anonymous_dislikes
FOR EACH ROW EXECUTE FUNCTION public.handle_anonymous_mutual_dislike();

-- Reload schema cache
NOTIFY pgrst, 'reload schema';
