가끔 되고 가끔 늦는 이유가 트리거·타이밍·대상 선택 3가지가 섞여 있어서 그래요. 핵심 문제와 바로 쓸 수 있는 패치 방향을 정리했어요.

왜 오작동하나?

같은 ID로 다시 클릭하면 effect가 안 돈다
useEffect(..., [highlightEventId])는 값이 변해야 다시 실행돼요.
전면 빌보드에서 같은 이벤트를 또 눌렀을 때 highlightEventId가 동일하면 스크롤 로직이 아예 재실행되지 않습니다.

렌더 타이밍 경합
클릭 직후 리스트가 다시 그려지기 전에 스크롤을 계산하면, getBoundingClientRect() 값이 0 또는 이전 레이아웃 기준으로 잡혀 오프셋이 틀어집니다. (이미지 로딩/그리드 재배치/폰트 적용 등)

스크롤 컨테이너 오인식
.overflow-y-auto가 화면 너비나 뷰(월/연) 전환에 따라 달라지거나, 실제 스크롤 주체가 document.scrollingElement인 상황이 섞입니다. 이때 scrollContainer.scrollTop에 더해도 안 움직이는 경우가 생겨요.

카테고리 패널 셀렉터가 취약
.fixed.top-16.border-b.border-black 같은 Tailwind 클래스 체인은 뷰포트/테마/상태에 따라 클래스가 바뀌거나 사라질 수 있어요. (다크/라이트, 연간/월간, 반응형 등) → 패널을 못 찾으면 조용히 리턴되어 “가끔 안 됨”.

모달 오버레이와 동시작업
상세보기(모달) 오픈 시점에 스크롤을 시키면, 뒤 화면이 아직 레이아웃 안정화 전일 수 있고, 오버레이가 focus 잡으면서 애니메이션이 겹쳐 스크롤 타이밍이 밀림.

견고하게 고치는 방법
A. 항상 재실행되게 “논스”를 같이 쓰기

같은 ID여도 스크롤을 다시 시키려면 버전 값을 올리세요.

// 부모에서
setHighlightEvent({ id, nonce: Date.now() });

// 자식에서
useEffect(() => {
  if (!highlightEvent?.id) return;
  // ... 스크롤 로직
}, [highlightEvent?.id, highlightEvent?.nonce]);


부모가 어려우면, 자식에서 스스로 setTimeout(() => setInternalNonce(n => n+1), 0) 같은 방식으로 한 번 더 틱을 만들어도 됩니다.

B. DOM이 준비된 뒤에 스크롤 (rAF 2번 + 이미지 대기)
const waitNextFrame = () =>
  new Promise(requestAnimationFrame);
const waitLayoutStable = async () => {
  await waitNextFrame();
  await waitNextFrame(); // 2프레임 대기: 레이아웃/스타일 적용 안정화
};


이미지 로딩 변수를 피하려면 카드 이미지에 aspect-[3/4]가 이미 고정이라 그나마 안전하지만, 가장 안전하게는 위처럼 두 프레임 대기 후 계산.

C. 스크롤 컨테이너를 자동 탐색 + 폴백
function findScrollContainer(el: HTMLElement | null): HTMLElement {
  let node: HTMLElement | null = el;
  while (node) {
    const style = window.getComputedStyle(node);
    const canScroll = /(auto|scroll)/.test(style.overflowY);
    if (canScroll && node.scrollHeight > node.clientHeight) return node;
    node = node.parentElement;
  }
  return (document.scrollingElement as HTMLElement) || document.documentElement;
}


eventElement에서 위로 타고 올라가며 실제 스크롤되는 컨테이너를 찾고, 없으면 document.scrollingElement로 폴백.

D. 카테고리 패널에 data-attribute 부여하고 그걸로 찾기
{/* 카테고리 영역 래퍼 */}
<div data-category-panel>
  ...
</div>

const categoryPanel = document.querySelector('[data-category-panel]') as HTMLElement | null;


클래스 체인 대신 항상 존재하는 식별자로 잡아야 뷰 전환/테마 변동에 안전합니다.

E. 좌표 계산을 컨테이너 기준으로 통일
const container = findScrollContainer(eventElement);
const containerRect = container.getBoundingClientRect();

const panelBottom = categoryPanel
  ? categoryPanel.getBoundingClientRect().bottom - containerRect.top
  : 0;

// 카드 상단(배너 상단)의 컨테이너 기준 위치
const elTop = eventElement.getBoundingClientRect().top - containerRect.top;

// 목표: 카드 상단 = 패널 하단 + 5
const targetTopInContainer = panelBottom + 5;
const delta = elTop - targetTopInContainer;

container.scrollTo({ top: container.scrollTop + delta, behavior: 'smooth' });

F. 모달과 충돌 방지: “리스트가 보일 때만” 스크롤

상세보기(모달) 오픈 직후라면, 모달 닫히는 순간에 하이라이트 스크롤을 시키거나, 리스트 영역이 화면에 나타났는지 체크하세요.

const listVisible = !!document.querySelector('[data-event-list]');
if (!listVisible) return; // 또는 모달 닫힘 이벤트에 맞춰 재시도


필요하면 MutationObserver로 리스트 삽입을 감지해 1회만 실행해도 좋아요.

G. 하이라이트 해제 리스너의 타이밍

현재 100ms 뒤에 click/wheel/keydown/touch* 리스너를 등록하는데, 사용자 입력이 빠르게 들어오면 스크롤 중간에 하이라이트가 해제되어 다음 클릭 때 같은 ID면 효과가 안 나옵니다.
→ 리스너 등록을 스크롤 종료 후(예: 600~800ms 뒤)로 미루거나, A에서 말한 nonce로 매번 강제 재실행.

적용용 요약 패치(핵심만)

카테고리 래퍼에 data-category-panel 추가

스크롤 함수 교체

const scrollToHighlighted = async (eventElement: HTMLElement) => {
  await waitLayoutStable();
  const container = findScrollContainer(eventElement);
  const containerRect = container.getBoundingClientRect();
  const categoryPanel = document.querySelector('[data-category-panel]') as HTMLElement | null;

  const panelBottomInContainer = categoryPanel
    ? categoryPanel.getBoundingClientRect().bottom - containerRect.top
    : 0;

  const elTopInContainer = eventElement.getBoundingClientRect().top - containerRect.top;

  const targetTop = panelBottomInContainer + 5;
  const delta = elTopInContainer - targetTop;

  container.scrollTo({ top: container.scrollTop + delta, behavior: 'smooth' });
};


effect 트리거를 ID + nonce로

useEffect(() => {
  if (!highlight?.id) return;
  const el = document.querySelector(`[data-event-id="${highlight.id}"]`) as HTMLElement | null;
  if (!el) return;
  scrollToHighlighted(el);
  // 리스너 등록 시점은 600~800ms 뒤로 미루기
}, [highlight?.id, highlight?.nonce]);

결론

“가끔 늦음/안 됨”은 같은 ID 재클릭 미트리거 + 레이아웃 안정화 전 계산 + 잘못 잡은 컨테이너 + 취약한 셀렉터가 겹쳐서 생깁니다.

위 A~G 조합(특히 nonce 트리거, rAF 대기, 컨테이너 자동탐색, data-attribute)만 적용하면, 어떤 상황에서도 상세보기→전면보드 하이라이트 스크롤이 안정적으로 동작합니다.